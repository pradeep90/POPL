				Notes

* Interface is represented by a tree
** just like the tree in the lec-6 slides
** [WRONG] just that here "method name" is used in place of "->"
** [WRONG] Note, therefore, you have to test for equality of the method name whereas earlier you just had arrows in both cases
* Design
  CLOCK: [2013-02-23 Sat 23:49]--[2013-02-24 Sun 00:05] =>  0:16
  CLOCK: [2013-02-23 Sat 23:06]--[2013-02-23 Sat 23:49] =>  0:43
  CLOCK: [2013-02-22 Fri 13:19]--[2013-02-22 Fri 13:57] =>  0:38
  CLOCK: [2013-02-22 Fri 13:00]--[2013-02-22 Fri 13:10] =>  0:10
** interface -> term automaton
*** Term Automaton = (\Sigma, Q, start, \delta, F)
*** \Sigma (input alphabet) = {0, 1} \cup {set of method names}
*** Set of states Q = {Int, Bool, Void, ->, Interface}
*** start = Interface
*** F is not needed as of now
*** VVIP \delta (Interface, method) = ->
**** VVIP Note: there is no name for the ->. It is all structural! We don't compare by name, we compare by structure. We don't care if you have the same name or not.
*** \delta (->, 0) = input type
*** \delta (->, 1) = return type
** term automaton * term automaton -> Product Automaton
*** Given two term automata M and N, we will construct a product automata (non-deterministic?)
*** We want to check whether M < N
*** A = (QA , Σ, q_{0}, δ A , F A )
*** QA = QM × QN × {0, 1}
*** VVIP Σ = \Sigma N
**** Basically, M should be able to respond to all inputs of N
*** qA = (qM , qN , 0) start state of A.
*** δ A : QA × Σ → QA .
*** For b, i ∈ Σ, p ∈ QM , and q ∈ QN , we have δ A ((p, q, b), i) = (δ M (p, i), δ N (q, i), b ⊕ πi) (⊕ = xor)
**** \Pi_i = parity of i
*** Final states
**** TODO Recall: s ≤ t iff {α ∈ D(s) ∩ D(t)|s(α) ≤πα t(α)}
***** Really???
***** VVIP Shouldn't it be "\alpha \in D(t)" alone?
***** In the definition of "subtyping", they say that every value described by s should be described by t
***** In the definition of "type ordering", they say that \alpha \in D(s) \cup D(t)
***** Let's try both and stick with the one that answers the test data
**** Goal: create an automata, where final states are denoted by states that will lead to ≤.
**** TODO F A = {(p, q, b)|lM (p) ≤b lN (q)} l gives the label of that node.
***** TODO Not sure what they mean by the label - ???. I'm assuming it is simply the state's name
** DFS: Can you reach some final state?
* Code
** DONE Generate all the auxiliary JTB and JavaCC files
   CLOCK: [2013-02-24 Sun 21:44]--[2013-02-24 Sun 21:46] =>  0:02
** DONE Change my-java-project-dir
   CLOCK: [2013-02-24 Sun 21:46]--[2013-02-24 Sun 21:55] =>  0:09
** DONE Term Automaton class
   CLOCK: [2013-02-24 Sun 21:56]--[2013-02-24 Sun 23:02] =>  1:06
** DONE Add a trivial test file
   CLOCK: [2013-02-24 Sun 23:02]--[2013-02-24 Sun 23:02] =>  0:00

** TODO Extend GJVoidDepthFirst
   CLOCK: [2013-02-24 Sun 23:09]--[2013-02-24 Sun 23:13] =>  0:04
** TODO Write trivial test case

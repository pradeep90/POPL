				Notes

* Plan
** Have an interface for Continuation
* Continuations
** Identify Simple Expressions and Tail Expressions
** My concern: how to make sure you can access the object's fields even in the continuation?
** Simple expressions should have no side-effects
** Expressions with side-effects - EOPL - pp 249
*** e.g., print(foo(3)) => foo 3 k(v) {print(v)}
*** Basically, print(simple expression) is fine
** TODO Why is CPS supposed to be better than the normal way of doing stuff (which is???)?
*** sure you get gotos at the end, but so does normal assembly language
*** I think the main advantage is that you have a method for translating functional code into imperative code
** Stack vs Tail-call optimization: My argument is that instead of growing the stack, you are growing the continuation structure...
*** Your continuation recursively grows as large as the stack.
*** I think it HAS to, if you want to remember all the context and shit.
*** I think originally tail-recursive functions will have continuations that don't grow as you go deeper and deeper. And stuff that wasn't tail-recursive to begin with, will have growing continuations
**** Check out the factorial example:
http://en.wikipedia.org/wiki/Continuation-passing_style#Examples
**** VVIP Note that in CPS, there is no implicit continuation-every call is a tail call. There is no "magic" here, as the continuation is simply explicitly passed. Using CPS without tail call optimization (TCO) will cause not only the constructed continuation to potentially grow during recursion, but also the call stack.
     http://en.wikipedia.org/wiki/Continuation-passing_style#CPS_and_tail_calls
* Microjava -> Nanojava
** Key idea: Nanojava programs are in tail-call style. However, that's not the same thing as CPS style.
*** Why not? CPS => Tail call. Tail call need not => CPS
*** Rather, CPS is a way of converting normal programs to Tail call style
*** If your program were already in tail-call style, you wouldn't need to pass around continuations (i.e., stuff that comes after this function call)
** Continuation: object, method name, arguments
*** extract continuation method: extract method on a bunch of statements (or a block or whatever)
**** Just create a new method containing those statements and ask the Visitor to convert the new method to Nanojava.
**** VVIP Make sure you pass OBJECTS as parameters instead of OBJECT.FIELD cos at the time of creating the continuation, the field may have some unknown value, whereas you want the field value at the time of execution of the continuation
***** VVIP i.e., System.out.println(foo.bar) becomes void printMethod(Foo foo, Continuation k){ System.out.println(foo.bar); }
*** get continuation class: get the class definition for the continuation
**** Just create an auxiliary class implementing Continuation which has the call() method.
*** get make continuation call: get the instantiation call (e.g., new A1(this, k, arguments)) we should put in the original location
*** VVIP Big problem: Classes don't have constructors in Nanojava.
**** VVIP Solution: Just set the fields directly.
** Expression: All of them are Simple Expressions
** Simple Statements:
*** AssignmentStatement() - Simple expression => Nanojava statement
*** ArrayAssignmentStatement() - simple expression => Nanojava statement
*** PrintStatement() - simple expression => Nanojava statement
** Tail form statements
*** For each of the following, if you see code beyond them, make a continuation out of that code and pass it in here.
*** Block() - 
**** Keep going till the end of the block
**** if you meet a jump, make a continuation from the rest of the block
**** else, just have a simple MessageSendStatement to the current continuation (which is by default k)
*** IfStatement() -
**** make both the if and else parts into Blocks with a jump to the current continuation if there is no explicit MessageSendStatement. Else, just call the MessageSendStatement.
*** WhileStatement() - extract the loop body into a method (and wrap that with the initial loop-expression IfStatement check) 
**** => loop-method: Block {if (exp) loop-body; jump to loop-method; else: call current continuation();}
**** Return a JumpPoint continuing the method call
*** MessageSendStatement() - Call it with the appropriate arguments (make it a Jump Point, btw)
** TODO Maybe you have to pass in the current continuation's name??
* Lessons
** Sometimes the formatted code will be wrapped around so it might seem a bit arbit but there is a method behind the madness
** Huge BUG: I never cleared currentClassContinuationMethods when visiting a new class. Damn!
*** Moral of the Story: Never use Globals when you can pass stuff along as parameters.
** I think it was a huge win to have ContinuationMaker as a separate class. Abstraction helps like hell.
** VVIP Note: ContinuationMaker only puts the parameters and local variables of the MicroJava method into the Continuation class. So, you can add as many local continuation variables as you want later.
* Actions
** DONE Set up basic files
   CLOCK: [2013-03-16 Sat 21:47]--[2013-03-16 Sat 22:05] =>  0:18
** DONE Think
   CLOCK: [2013-03-17 Sun 23:27]--[2013-03-18 Mon 00:51] =>  1:24
   CLOCK: [2013-03-17 Sun 23:02]--[2013-03-17 Sun 23:15] =>  0:13
   CLOCK: [2013-03-17 Sun 17:50]--[2013-03-17 Sun 17:59] =>  0:09
   CLOCK: [2013-03-17 Sun 16:14]--[2013-03-17 Sun 17:25] =>  1:11
   CLOCK: [2013-03-16 Sat 22:08]--[2013-03-16 Sat 23:05] =>  0:57

** DONE Make the package name "nano"
   CLOCK: [2013-03-21 Thu 17:14]--[2013-03-21 Thu 17:18] =>  0:04
** DONE GJ no argu
** DONE Add CPSHelper stuff
   CLOCK: [2013-03-21 Thu 17:33]--[2013-03-21 Thu 17:57] =>  0:24
** DONE Add tests for Nano versions of CPSHelper methods
   CLOCK: [2013-03-22 Fri 02:02]--[2013-03-22 Fri 02:20] =>  0:18
** DONE SimpleSum.java - Nanojava code
   CLOCK: [2013-03-22 Fri 02:58]--[2013-03-22 Fri 04:07] =>  1:09
   CLOCK: [2013-03-22 Fri 02:36]--[2013-03-22 Fri 02:58] =>  0:22
** DONE PrimaryExpression
   :PROPERTIES:
   :Effort:   15
   :END:
*** DONE IntegerLiteral()
*** DONE TrueLiteral()
    CLOCK: [2013-03-22 Fri 05:43]--[2013-03-22 Fri 05:49] =>  0:06
*** DONE FalseLiteral()
*** DONE VarRef()
*** DONE ThisExpression()
    CLOCK: [2013-03-22 Fri 05:55]--[2013-03-22 Fri 05:55] =>  0:00
*** DONE ArrayAllocationExpression()
    CLOCK: [2013-03-22 Fri 05:55]--[2013-03-22 Fri 05:57] =>  0:02
*** DONE AllocationExpression()
    CLOCK: [2013-03-22 Fri 05:57]--[2013-03-22 Fri 05:58] =>  0:01
*** DONE NotExpression()
    CLOCK: [2013-03-22 Fri 05:58]--[2013-03-22 Fri 05:58] =>  0:00
*** DONE BracketExpression()
    CLOCK: [2013-03-22 Fri 05:58]--[2013-03-22 Fri 05:59] =>  0:01
** DONE Expressions
   CLOCK: [2013-03-22 Fri 06:02]--[2013-03-22 Fri 06:05] =>  0:03
*** DONE AndExpression()
    CLOCK: [2013-03-22 Fri 06:01]--[2013-03-22 Fri 06:02] =>  0:01
*** CompareExpression()
*** PlusExpression()
*** MinusExpression()
*** TimesExpression()
*** ArrayLookup()
*** PrimaryExpression()
** DONE AssignmentStatement
   CLOCK: [2013-03-22 Fri 06:06]--[2013-03-22 Fri 06:06] =>  0:00

** DONE ArrayAssignmentStatement
   CLOCK: [2013-03-22 Fri 06:07]--[2013-03-22 Fri 06:08] =>  0:01
** DONE PrintStatement
   CLOCK: [2013-03-22 Fri 06:08]--[2013-03-22 Fri 06:08] =>  0:00
** DONE ExpressionList, etc.
   CLOCK: [2013-03-22 Fri 06:34]--[2013-03-22 Fri 06:42] =>  0:08
** DONE Basic versions of the Tail Form statements
*** DONE Block
    CLOCK: [2013-03-22 Fri 06:46]--[2013-03-22 Fri 07:22] =>  0:36
    CLOCK: [2013-03-22 Fri 06:30]--[2013-03-22 Fri 06:33] =>  0:03
*** DONE If
    CLOCK: [2013-03-22 Fri 07:22]--[2013-03-22 Fri 07:45] =>  0:23
*** DONE MessageSendStatement
    CLOCK: [2013-03-22 Fri 06:42]--[2013-03-22 Fri 06:46] =>  0:04
    CLOCK: [2013-03-22 Fri 06:33]--[2013-03-22 Fri 06:34] =>  0:01

** DONE Type
   CLOCK: [2013-03-22 Fri 08:00]--[2013-03-22 Fri 08:01] =>  0:01

** DONE FormalParameterList
   CLOCK: [2013-03-22 Fri 08:02]--[2013-03-22 Fri 08:06] =>  0:04

** DONE MethodDeclaration
   CLOCK: [2013-03-22 Fri 08:40]--[2013-03-22 Fri 08:59] =>  0:19
   CLOCK: [2013-03-22 Fri 08:06]--[2013-03-22 Fri 08:36] =>  0:30

** DONE ClassDeclaration
   CLOCK: [2013-03-22 Fri 09:01]--[2013-03-22 Fri 09:25] =>  0:24
*** DONE Check out why SimpleSum -> Nanojava -> string gives an error
    CLOCK: [2013-03-22 Fri 13:27]--[2013-03-22 Fri 13:28] =>  0:01
    CLOCK: [2013-03-22 Fri 13:09]--[2013-03-22 Fri 13:27] =>  0:18

** DONE Block => Transformation
   CLOCK: [2013-03-23 Sat 10:20]--[2013-03-23 Sat 10:36] =>  0:16
   CLOCK: [2013-03-23 Sat 09:11]--[2013-03-23 Sat 10:15] =>  1:04
   CLOCK: [2013-03-22 Fri 17:05]--[2013-03-22 Fri 17:09] =>  0:04
   CLOCK: [2013-03-22 Fri 13:34]--[2013-03-22 Fri 15:00] =>  1:26
*** DONE Make IfStatement and MessageSendStatement return JumpPoint
    CLOCK: [2013-03-23 Sat 09:09]--[2013-03-23 Sat 09:11] =>  0:02
** DONE ContinuationMaker
   CLOCK: [2013-03-22 Fri 21:41]--[2013-03-22 Fri 22:40] =>  0:59
   CLOCK: [2013-03-22 Fri 17:09]--[2013-03-22 Fri 17:44] =>  0:35
*** DONE Test for different combos of parameters and local variables
    CLOCK: [2013-03-22 Fri 22:40]--[2013-03-22 Fri 22:58] =>  0:18
*** DONE Make class
    CLOCK: [2013-03-22 Fri 22:58]--[2013-03-23 Sat 01:01] =>  2:03
** DONE Add the Base Continuation class
   CLOCK: [2013-03-23 Sat 10:38]--[2013-03-23 Sat 10:40] =>  0:02
** DONE Fix currentClassContinuationMethods BUG
   CLOCK: [2013-03-23 Sat 10:45]--[2013-03-23 Sat 11:59] =>  1:14
*** Make makeContinuationMethod deepcopy Nodes
** DONE Pass current continuation around in an environment
   CLOCK: [2013-03-23 Sat 14:36]--[2013-03-23 Sat 14:37] =>  0:01
   CLOCK: [2013-03-23 Sat 12:48]--[2013-03-23 Sat 14:30] =>  1:42
*** current method name too
*** current class too for the heck of it
** DONE Declare new continuation variable at the start of method
   CLOCK: [2013-03-23 Sat 15:06]--[2013-03-23 Sat 15:30] =>  0:24
   CLOCK: [2013-03-23 Sat 14:39]--[2013-03-23 Sat 15:06] =>  0:27
** DONE Have proper types for the local continuation variables
   CLOCK: [2013-03-24 Sun 00:46]--[2013-03-24 Sun 01:06] =>  0:20
** TODO Only copy into the Continuation those fields that have been initialized
   CLOCK: [2013-03-24 Sun 01:06]--[2013-03-24 Sun 02:32] =>  1:26
*** There are two things here:
**** setting fields of the new continuation instance so that the values of the variables are carried forward
**** having local variables in the new continuation method so that the code actually works 
*** fields of the continuation = variables used in the remainingStatements && initialized before current statement
**** This also includes the original method's parameters (cos they have been initialized)
*** local variables of the continuation = variables used in the remainingStatements && not initialized before current statement
*** VVIP For our purposes, I will assume that all variables are being used in remainingStatements (no need to check usage)
*** VVIP So, take (parameters + local variables) for the original method. Those that have been initialized before current statement will be fields of the continuation. The rest are local variables in the continuation method.
*** TODO Make Block save and restore currentMethodInitializedVariables so that "if (b) {x = 1} else{foo.bar();}" does not lead to "else" thinking that x has been initialized.
    CLOCK: [2013-03-24 Sun 02:33]--[2013-03-24 Sun 02:50] =>  0:17
*** My idea: get the initializedVars list for the if and else block separately and then say method's initializedVars list = intersection of those two
    CLOCK: [2013-03-24 Sun 02:50]--[2013-03-24 Sun 03:39] =>  0:49
**** Note: If some variable gets initialized in only one of the blocks, then it is illegal to refer to it after the if-else statement cos it could be undefined.
** Another idea: Instead of looking for variables that have been initialized so far (which can be difficult), look at variables that are being referenced in the given bunch of statements
   CLOCK: [2013-03-24 Sun 03:59]--[2013-03-24 Sun 04:58] =>  0:59
*** visit (node) -> true iff we have come to a decision about whether variable is initialized in node or it is live in node.
*** isLive -> true iff the variable is live in the entire node under consideration
*** So, visit () == true && isLive == true: live variable
*** So, visit () == true && isLive == false: non-live variable
*** So, visit () == false: non-live variable
*** Note: Statements must short-circuit - if 
** Use the live variables idea and ContinuationMaker
   CLOCK: [2013-03-24 Sun 04:59]--[2013-03-24 Sun 05:29] =>  0:30
*** TODO Remove references to initializedVars
** DONE Problem with if-else statement is that the trailingStatements might refer to a variable that only gets initialized within the if-else-block, but instantiating the continuation before the block leads to potentially using an uninitialized variable. 
*** TODO Solution: Move the continuation instantiation to the end of the simple statements in each of the if-else blocks.
    CLOCK: [2013-03-24 Sun 13:20]--[2013-03-24 Sun 13:34] =>  0:14
**** DONE Be careful about not using the same instances in both blocks
**** DONE Make sure that currInitStatements can't get overwritten by recursive calls to ContinuationMaker
**** DONE Problem: the currInitStatements are being included even in the continuation method cos I'm not clearing it, I guess.
***** TODO Thing is I need to clear it after using it in BOTH the if block AND the else block.
*** TODO The previous "Solution" is wrong cos logically you need to put the remainingStatements at the END of each of the if and else blocks, not just at the end of the simple statements in those blocks.
**** But you can't just copy-paste the remainingStatements in both the blocks cos that might lead to you making duplicate continuation methods
**** So, create a continuation for remainingStatements, and add the initStatements for that continuation at the end of both the blocks
**** There are only 3 types of tail-form statements you'll come across in Block
***** TODO IfStatement: append initStatements to both the if and else blocks
    CLOCK: [2013-03-24 Sun 14:00]--[2013-03-24 Sun 14:30] =>  0:30
****** I've got the initStatementsMicro
****** DONE Where to put them?
****** TODO Only problem is that I use the parameters and local variables of parentMethod to determine the local variables of the continuation - but the initStatementsMicro would refer to k1 which is not really declared in the parentMethod.
****** TODO Solution: Use LiveVariableFinder: if visit () == true && isLive == false, it means it is a local variable (not a parameter)
       CLOCK: [2013-03-24 Sun 14:32]--[2013-03-24 Sun 14:59] =>  0:27
***** Debug Factorial
      CLOCK: [2013-03-24 Sun 14:59]--[2013-03-24 Sun 15:24] =>  0:25
***** TODO when adding initStatementsMicro at the end, if it there is no JumpPoint at the end, do k1.call() instead of k.call()
****** DONE i.e., make k1 the currentContinuation name when instantiating a new continuation inside a continuation method
       CLOCK: [2013-03-24 Sun 16:00]--[2013-03-24 Sun 16:46] =>  0:46
       CLOCK: [2013-03-24 Sun 15:24]--[2013-03-24 Sun 15:28] =>  0:04
******* DONE Maybe whenever you see "k1 = new ContinuationClasscontinuationMethod0 ()" set currentContinuation name = k1
******* That is the behaviour you want
******* DONE Whenever you instantiate a continuation you intend to make it the current continuation. It's just that for IfStatement, you are defering the insertion of the initStatementsMicro, so the information about kNameCounter++ is lost
******* DONE In fact, make this the default way kNameCounter is updated (but I still need to do the kNameCounter++ when calling ContinuationMaker anyway)
****** Finally done! I was SO afraid I wouldn't be able to get any test program working! Rationality FUCKING rocks!!!
****** A little more faith next time :P
***** WhileStatement: append initStatements to the else block of the while method
** DONE Check out why when you have k1, k2, in "else", it's k2.k = k instead of k2.k1 = k1
** TODO Test output for MicroJava examples
   CLOCK: [2013-03-24 Sun 17:14]--[2013-03-24 Sun 18:02] =>  0:48
   CLOCK: [2013-03-24 Sun 16:46]--[2013-03-24 Sun 17:00] =>  0:14
*** MultilevelInherit, ThisExpr - I think they both have subclassing
**** I think a base class variable is assigned subclass instances
**** Plus, they are calling different methods... I don't know yet
*** Others - They all have WhileStatement. So can't say anything else without implementing WhileStatement.
*** TODO Plus, some of them have a block inside the WhileStatement block
** DONE k2.object = this
** DONE Uniquify the class and method names for Continuations, plus the parameter names
** TODO WhileStatement
   CLOCK: [2013-03-25 Mon 00:46]--[2013-03-25 Mon 01:19] =>  0:33
   CLOCK: [2013-03-24 Sun 18:06]--[2013-03-24 Sun 18:48] =>  0:42
*** Reuse makeContinuationMethod - Only, instead of trailingStatements, give it if(exp){body; recursive-call();}else{initStatements}
**** TODO initStatements
**** TODO recursive-call
     CLOCK: [2013-03-25 Mon 20:18]--[2013-03-25 Mon 21:18] =>  1:00
     CLOCK: [2013-03-25 Mon 02:30]--[2013-03-25 Mon 02:40] =>  0:10
     CLOCK: [2013-03-25 Mon 01:19]--[2013-03-25 Mon 01:25] =>  0:06
***** tmp = this; tmp.whileMethod (args)
***** DONE Put "tmp.whileMethod (args)" at the end of the if block
      CLOCK: [2013-03-25 Mon 21:18]--[2013-03-25 Mon 21:39] =>  0:21
**** DONE Add the tmp VarDeclaration and tmp = this statement to the method
     CLOCK: [2013-03-25 Mon 21:40]--[2013-03-25 Mon 21:44] =>  0:04
**** TODO Add tmp.whileMethod (args) call in the original location
** DONE Handle nested blocks
*** have a recursive function flattenBlock (Block -> Statement List) to flattenBlock the inner statements from the Block and return the list of statements
*** Or tryFlattenBlock (Block -> Statement)
    CLOCK: [2013-03-25 Mon 01:25]--[2013-03-25 Mon 02:28] =>  1:03
**** Block (block) -> tryFlattenBlock (block)
**** Block (non-block statement) -> statement
**** Block (statements) -> Do tryFlattenBlock (Block (statement)) and extract the body of the Block
** TODO Test for sub classes

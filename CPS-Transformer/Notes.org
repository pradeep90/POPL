				Notes

* Plan
** Have an interface for Continuation
* Continuations
** Identify Simple Expressions and Tail Expressions
** My concern: how to make sure you can access the object's fields even in the continuation?
** Simple expressions should have no side-effects
** Expressions with side-effects - EOPL - pp 249
*** e.g., print(foo(3)) => foo 3 k(v) {print(v)}
*** Basically, print(simple expression) is fine
** TODO Why is CPS supposed to be better than the normal way of doing stuff (which is???)?
*** sure you get gotos at the end, but so does normal assembly language
*** I think the main advantage is that you have a method for translating functional code into imperative code
** Stack vs Tail-call optimization: My argument is that instead of growing the stack, you are growing the continuation structure...
*** Your continuation recursively grows as large as the stack.
*** I think it HAS to, if you want to remember all the context and shit.
*** I think originally tail-recursive functions will have continuations that don't grow as you go deeper and deeper. And stuff that wasn't tail-recursive to begin with, will have growing continuations
**** Check out the factorial example:
http://en.wikipedia.org/wiki/Continuation-passing_style#Examples
**** VVIP Note that in CPS, there is no implicit continuation-every call is a tail call. There is no "magic" here, as the continuation is simply explicitly passed. Using CPS without tail call optimization (TCO) will cause not only the constructed continuation to potentially grow during recursion, but also the call stack.
     http://en.wikipedia.org/wiki/Continuation-passing_style#CPS_and_tail_calls
* Microjava -> Nanojava
** Key idea: Nanojava programs are in tail-call style. However, that's not the same thing as CPS style.
*** Why not? CPS => Tail call. Tail call need not => CPS
*** Rather, CPS is a way of converting normal programs to Tail call style
*** If your program were already in tail-call style, you wouldn't need to pass around continuations (i.e., stuff that comes after this function call)
** Continuation: object, method name, arguments
*** extract continuation method: extract method on a bunch of statements (or a block or whatever)
**** Just create a new method containing those statements and ask the Visitor to convert the new method to Nanojava.
**** VVIP Make sure you pass OBJECTS as parameters instead of OBJECT.FIELD cos at the time of creating the continuation, the field may have some unknown value, whereas you want the field value at the time of execution of the continuation
***** VVIP i.e., System.out.println(foo.bar) becomes void printMethod(Foo foo, Continuation k){ System.out.println(foo.bar); }
*** get continuation class: get the class definition for the continuation
**** Just create an auxiliary class implementing Continuation which has the call() method.
*** get make continuation call: get the instantiation call (e.g., new A1(this, k, arguments)) we should put in the original location
*** VVIP Big problem: Classes don't have constructors in Nanojava.
**** VVIP Solution: Just set the fields directly.
** Expression: All of them are Simple Expressions
** Simple Statements:
*** AssignmentStatement() - Simple expression => Nanojava statement
*** ArrayAssignmentStatement() - simple expression => Nanojava statement
*** PrintStatement() - simple expression => Nanojava statement
** Tail form statements
*** For each of the following, if you see code beyond them, make a continuation out of that code and pass it in here.
*** Block() - 
**** Keep going till the end of the block
**** if you meet a jump, make a continuation from the rest of the block
**** else, just have a simple MessageSendStatement to the current continuation (which is by default k)
*** IfStatement() -
**** make both the if and else parts into Blocks with a jump to the current continuation if there is no explicit MessageSendStatement. Else, just call the MessageSendStatement.
*** WhileStatement() - extract the loop body into a method (and wrap that with the initial loop-expression IfStatement check) 
**** => loop-method: Block {if (exp) loop-body; jump to loop-method; else: call current continuation();}
*** MessageSendStatement() - Call it with the appropriate arguments (make it a Jump Point, btw)
** TODO Maybe you have to pass in the current continuation's name??
* Actions
** DONE Set up basic files
   CLOCK: [2013-03-16 Sat 21:47]--[2013-03-16 Sat 22:05] =>  0:18
** DONE Think
   CLOCK: [2013-03-17 Sun 23:27]--[2013-03-18 Mon 00:51] =>  1:24
   CLOCK: [2013-03-17 Sun 23:02]--[2013-03-17 Sun 23:15] =>  0:13
   CLOCK: [2013-03-17 Sun 17:50]--[2013-03-17 Sun 17:59] =>  0:09
   CLOCK: [2013-03-17 Sun 16:14]--[2013-03-17 Sun 17:25] =>  1:11
   CLOCK: [2013-03-16 Sat 22:08]--[2013-03-16 Sat 23:05] =>  0:57

** DONE Make the package name "nano"
   CLOCK: [2013-03-21 Thu 17:14]--[2013-03-21 Thu 17:18] =>  0:04
** DONE GJ no argu
** DONE Add CPSHelper stuff
   CLOCK: [2013-03-21 Thu 17:33]--[2013-03-21 Thu 17:57] =>  0:24
** DONE Add tests for Nano versions of CPSHelper methods
   CLOCK: [2013-03-22 Fri 02:02]--[2013-03-22 Fri 02:20] =>  0:18
** DONE SimpleSum.java - Nanojava code
   CLOCK: [2013-03-22 Fri 02:58]--[2013-03-22 Fri 04:07] =>  1:09
   CLOCK: [2013-03-22 Fri 02:36]--[2013-03-22 Fri 02:58] =>  0:22
** DONE PrimaryExpression
   :PROPERTIES:
   :Effort:   15
   :END:
*** DONE IntegerLiteral()
*** DONE TrueLiteral()
    CLOCK: [2013-03-22 Fri 05:43]--[2013-03-22 Fri 05:49] =>  0:06
*** DONE FalseLiteral()
*** DONE VarRef()
*** DONE ThisExpression()
    CLOCK: [2013-03-22 Fri 05:55]--[2013-03-22 Fri 05:55] =>  0:00
*** DONE ArrayAllocationExpression()
    CLOCK: [2013-03-22 Fri 05:55]--[2013-03-22 Fri 05:57] =>  0:02
*** DONE AllocationExpression()
    CLOCK: [2013-03-22 Fri 05:57]--[2013-03-22 Fri 05:58] =>  0:01
*** DONE NotExpression()
    CLOCK: [2013-03-22 Fri 05:58]--[2013-03-22 Fri 05:58] =>  0:00
*** DONE BracketExpression()
    CLOCK: [2013-03-22 Fri 05:58]--[2013-03-22 Fri 05:59] =>  0:01
** DONE Expressions
   CLOCK: [2013-03-22 Fri 06:02]--[2013-03-22 Fri 06:05] =>  0:03
*** DONE AndExpression()
    CLOCK: [2013-03-22 Fri 06:01]--[2013-03-22 Fri 06:02] =>  0:01
*** CompareExpression()
*** PlusExpression()
*** MinusExpression()
*** TimesExpression()
*** ArrayLookup()
*** PrimaryExpression()
** DONE AssignmentStatement
   CLOCK: [2013-03-22 Fri 06:06]--[2013-03-22 Fri 06:06] =>  0:00

** DONE ArrayAssignmentStatement
   CLOCK: [2013-03-22 Fri 06:07]--[2013-03-22 Fri 06:08] =>  0:01
** DONE PrintStatement
   CLOCK: [2013-03-22 Fri 06:08]--[2013-03-22 Fri 06:08] =>  0:00
** DONE ExpressionList, etc.
   CLOCK: [2013-03-22 Fri 06:34]--[2013-03-22 Fri 06:42] =>  0:08
** DONE Basic versions of the Tail Form statements
*** DONE Block
    CLOCK: [2013-03-22 Fri 06:46]--[2013-03-22 Fri 07:22] =>  0:36
    CLOCK: [2013-03-22 Fri 06:30]--[2013-03-22 Fri 06:33] =>  0:03
*** DONE If
    CLOCK: [2013-03-22 Fri 07:22]--[2013-03-22 Fri 07:45] =>  0:23
*** DONE MessageSendStatement
    CLOCK: [2013-03-22 Fri 06:42]--[2013-03-22 Fri 06:46] =>  0:04
    CLOCK: [2013-03-22 Fri 06:33]--[2013-03-22 Fri 06:34] =>  0:01

** DONE Type
   CLOCK: [2013-03-22 Fri 08:00]--[2013-03-22 Fri 08:01] =>  0:01

** DONE FormalParameterList
   CLOCK: [2013-03-22 Fri 08:02]--[2013-03-22 Fri 08:06] =>  0:04

** DONE MethodDeclaration
   CLOCK: [2013-03-22 Fri 08:40]--[2013-03-22 Fri 08:59] =>  0:19
   CLOCK: [2013-03-22 Fri 08:06]--[2013-03-22 Fri 08:36] =>  0:30

** TODO ClassDeclaration
   CLOCK: [2013-03-22 Fri 09:01]--[2013-03-22 Fri 09:25] =>  0:24
*** TODO Check out why SimpleSum -> Nanojava -> string gives an error

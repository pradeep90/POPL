				Notes

* Test cases
* My trials
** pub1
*** 
* Grammar
** Goal 	::= 	Expression <EOF>
** Expression 	::= 	IntegerLiteral
*** | 	TrueLiteral
*** | 	FalseLiteral
*** | 	PlusExpression
*** | 	IfExpression
*** | 	LetExpression
*** | 	Identifier
*** | 	Assignment
*** | 	ProcedureExp
*** | 	Application
*** | 	RecExpression
** IntegerLiteral 	::= 	<INTEGER_LITERAL>
** TrueLiteral 	::= 	"#t"
** FalseLiteral 	::= 	"#f"
** PlusExpression 	::= 	"(" "+" Expression Expression ")"
** IfExpression 	::= 	"(" "if" Expression Expression Expression ")"
** LetExpression 	::= 	"(" "let" "(" ( Declaration )* ")" Expression ")"
** Identifier 	::= 	<IDENTIFIER>
** Assignment 	::= 	"(" "set!" Identifier Expression ")"
** ProcedureExp 	::= 	"(" "lambda" "(" ( Identifier )* ")" Expression ")"
** Application 	::= 	"(" Expression ( Expression )* ")"
** RecExpression 	::= 	"(" "letrec" "(" ( RecDeclaration )* ")" Expression ")"
** Declaration 	::= 	"(" Identifier Expression ")"
** RecDeclaration 	::= 	"(" Identifier ProcedureExp ")"
* Types
** Goal
** Expression
*** | 	TrueLiteral
*** | 	FalseLiteral
*** | 	PlusExpression
*** | 	IfExpression
*** | 	LetExpression
*** | 	Identifier
*** | 	Assignment
*** | 	ProcedureExp
*** | 	Application
*** | 	RecExpression
** IntegerLiteral
*** return IntType
** TrueLiteral
*** return boolean
** FalseLiteral
*** return boolean
** PlusExpression
*** return int
*** add equations (type of expr1 = int), (type of expr2 = int)
** IfExpression
*** return new type t_k
*** add equations
**** type of clause = bool
**** type of expr1 = t_k
**** type of expr2 = t_k
** LetExpression
*** return t_k
*** let the declarations do their business (in a copy of the type environment and with a copy of the id-list) 
*** make sure the declarations can't get at each other or themselves. They can only refer to types in the parent environment
*** add equation: type of expression = t_k
** Identifier - ?
** Assignment - (old type??)
** ProcedureExp
*** return t_k
*** extend copy of the type environment with declarations' stuff
*** add equation: t_k = type of expression
** Application
*** return t_k
*** add equation: t_k = return type of function-expression
*** add equation: argument type of function-expression = (type of expr1, ...)
** RecExpression - 
*** return t_k
*** let the declarations do their business (in a copy of the type environment and with a copy of the id-list) 
*** However, cos this is letrec, make nominal types for the declarations right at the beginning (and add them to the id list) so that they can refer to themselves and each other.
**** I think you can do this in RecDeclaration
*** add equation: type of expression = t_k
** Declaration
** RecDeclaration
* Action Plan
** I think you have to build up an Environment-like data structure as you traverse the parse tree
** Parse Tree => Set of equations
** Unification algorithm: Set of equations => Type for the top-level function (or "Does not type check")
* VVIP Parse tree => Set of equations
** Each node returns its type
** Inside, it also adds a bunch of equations to G
* Lessons
** Note: you won't be able to see the changes made by the declarations in a LetExpression cos they'll happen in an extended letTypeEnvironment.
** I'm choosing to return the type of the expression in Declaration instead of extending the environment cos we don't want them to refer to the preceding declarations (which will happen if you let them extend the environment)
** TODO what is the type of a function 
*** (lambda (x y) (+ x y))
*** Is it int -> int -> int
*** But then, what is the type of (lambda (x) (lambda (y) (+ x y)))
*** Isn't that also int -> int -> int
*** No, I think that is int -> (int -> int)
** VVIP Make sure you reset static counters in setUp so that they start from 0 for every test case
* Steps
** DONE Set up the boiler-plate code
   CLOCK: [2013-03-09 Sat 23:43]--[2013-03-09 Sat 23:50] =>  0:07
** DONE Get a basic Parser running
   CLOCK: [2013-03-09 Sat 23:51]--[2013-03-09 Sat 23:54] =>  0:03
** DONE Type
   CLOCK: [2013-03-10 Sun 00:02]--[2013-03-10 Sun 00:03] =>  0:01
   :PROPERTIES:
   :Effort:   15
   :END:
*** DONE Base class
    CLOCK: [2013-03-10 Sun 00:03]--[2013-03-10 Sun 00:03] =>  0:00
*** DONE int
    CLOCK: [2013-03-10 Sun 00:04]--[2013-03-10 Sun 00:07] =>  0:03
*** boolean
*** unknown
*** function
** DONE TypeEnvironment - LinkedList
   CLOCK: [2013-03-10 Sun 00:07]--[2013-03-10 Sun 00:10] =>  0:03
   :PROPERTIES:
   :Effort:   5
   :END:
*** identifier => Type
** DONE Simple types
   CLOCK: [2013-03-10 Sun 00:12]--[2013-03-10 Sun 00:12] =>  0:00
   :PROPERTIES:
   :Effort:   30
   :END:
*** DONE see if it reads stuff properly
    CLOCK: [2013-03-10 Sun 00:25]--[2013-03-10 Sun 00:26] =>  0:01
    CLOCK: [2013-03-10 Sun 00:12]--[2013-03-10 Sun 00:25] =>  0:13
*** DONE TrueLiteral
    CLOCK: [2013-03-10 Sun 00:28]--[2013-03-10 Sun 00:31] =>  0:03
*** DONE FalseLiteral
    CLOCK: [2013-03-10 Sun 00:31]--[2013-03-10 Sun 00:34] =>  0:03
*** DONE IntegerLiteral
    CLOCK: [2013-03-10 Sun 00:34]--[2013-03-10 Sun 00:38] =>  0:04

** DONE Make this just collect every TypeEquation (i.e., NOT TypeInferrer, just TypeEquationCollector)
** DONE TypeEquation
   CLOCK: [2013-03-10 Sun 19:23]--[2013-03-10 Sun 19:26] =>  0:03
** DONE PlusExpression
   CLOCK: [2013-03-10 Sun 19:26]--[2013-03-10 Sun 19:52] =>  0:26
   :PROPERTIES:
   :Effort:   5
   :END:
** DONE Add newUnknownType counter
** DONE IfExpression
   CLOCK: [2013-03-10 Sun 19:58]--[2013-03-10 Sun 20:05] =>  0:07
   :PROPERTIES:
   :Effort:   07
   :END:
** DONE LetExpression
   CLOCK: [2013-03-11 Mon 19:52]--[2013-03-11 Mon 20:07] =>  0:15
   CLOCK: [2013-03-11 Mon 19:49]--[2013-03-11 Mon 19:52] =>  0:03
   CLOCK: [2013-03-11 Mon 19:43]--[2013-03-11 Mon 19:47] =>  0:04
   CLOCK: [2013-03-11 Mon 19:27]--[2013-03-11 Mon 19:30] =>  0:03
** DONE Identifier
   CLOCK: [2013-03-11 Mon 19:47]--[2013-03-11 Mon 19:49] =>  0:02
** DONE Declaration
   CLOCK: [2013-03-11 Mon 19:30]--[2013-03-11 Mon 19:43] =>  0:13
** DONE Assignment
   CLOCK: [2013-03-12 Tue 11:02]--[2013-03-12 Tue 11:34] =>  0:32
   CLOCK: [2013-03-11 Mon 20:56]--[2013-03-11 Mon 21:02] =>  0:06
** DONE RecExpression
   CLOCK: [2013-03-11 Mon 22:15]--[2013-03-11 Mon 22:27] =>  0:12
   :PROPERTIES:
   :Effort:   10
   :END:
** DONE getFunctionType
   CLOCK: [2013-03-12 Tue 11:54]--[2013-03-12 Tue 11:55] =>  0:01
   CLOCK: [2013-03-12 Tue 11:54]--[2013-03-12 Tue 11:54] =>  0:00
   CLOCK: [2013-03-12 Tue 11:50]--[2013-03-12 Tue 11:54] =>  0:04
   CLOCK: [2013-03-11 Mon 21:21]--[2013-03-11 Mon 21:38] =>  0:17
** DONE ProcedureExp
   CLOCK: [2013-03-12 Tue 11:55]--[2013-03-12 Tue 12:05] =>  0:10
   CLOCK: [2013-03-12 Tue 11:49]--[2013-03-12 Tue 11:50] =>  0:01
   CLOCK: [2013-03-11 Mon 21:03]--[2013-03-11 Mon 21:21] =>  0:18
   :PROPERTIES:
   :Effort:   40
   :END:
** DONE Application
   CLOCK: [2013-03-12 Tue 12:06]--[2013-03-12 Tue 12:47] =>  0:41
   :PROPERTIES:
   :Effort:   20
   :END:
** TODO Take care of Application and ProcedureExp with no arguments
** DONE Then, write a Unifier class
   CLOCK: [2013-03-11 Mon 22:27]--[2013-03-11 Mon 23:25] =>  0:58
** TODO Make sure that "Does not type check" in TypeEquationCollector (for recursive stuff in normal LetExpression) is ok when it usually comes in Unifier
